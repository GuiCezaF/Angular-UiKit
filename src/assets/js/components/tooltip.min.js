/*! UIkit 3.16.1 | https://www.getuikit.com | (c) 2014 - 2023 YOOtheme | MIT License */(function(s,g){typeof exports=="object"&&typeof module<"u"?module.exports=g(require("uikit-util")):typeof define=="function"&&define.amd?define("uikittooltip",["uikit-util"],g):(s=typeof globalThis<"u"?globalThis:s||self,s.UIkitTooltip=g(s.UIkit.util))})(this,function(s){"use strict";var g={props:{container:Boolean},data:{container:!0},computed:{container({container:o}){return o===!0&&this.$container||o&&s.$(o)}}},S={props:{cls:Boolean,animation:"list",duration:Number,velocity:Number,origin:String,transition:String},data:{cls:!1,animation:[!1],duration:200,velocity:.2,origin:!1,transition:"ease",clsEnter:"uk-togglabe-enter",clsLeave:"uk-togglabe-leave"},computed:{hasAnimation({animation:o}){return!!o[0]},hasTransition({animation:o}){return["slide","reveal"].some(e=>s.startsWith(o[0],e))}},methods:{toggleElement(o,e,t){return new Promise(n=>Promise.all(s.toNodes(o).map(r=>{const i=s.isBoolean(e)?e:!this.isToggled(r);if(!s.trigger(r,`before${i?"show":"hide"}`,[this]))return Promise.reject();const h=(s.isFunction(t)?t:t===!1||!this.hasAnimation?B:this.hasTransition?I:D)(r,i,this),a=i?this.clsEnter:this.clsLeave;s.addClass(r,a),s.trigger(r,i?"show":"hide",[this]);const c=()=>{s.removeClass(r,a),s.trigger(r,i?"shown":"hidden",[this])};return h?h.then(c,()=>(s.removeClass(r,a),Promise.reject())):c()})).then(n,s.noop))},isToggled(o=this.$el){return[o]=s.toNodes(o),s.hasClass(o,this.clsEnter)?!0:s.hasClass(o,this.clsLeave)?!1:this.cls?s.hasClass(o,this.cls.split(" ")[0]):s.isVisible(o)},_toggle(o,e){if(!o)return;e=Boolean(e);let t;this.cls?(t=s.includes(this.cls," ")||e!==s.hasClass(o,this.cls),t&&s.toggleClass(o,this.cls,s.includes(this.cls," ")?void 0:e)):(t=e===o.hidden,t&&(o.hidden=!e)),s.$$("[autofocus]",o).some(n=>s.isVisible(n)?n.focus()||!0:n.blur()),t&&s.trigger(o,"toggled",[e,this])}}};function B(o,e,{_toggle:t}){return s.Animation.cancel(o),s.Transition.cancel(o),t(o,e)}async function I(o,e,{animation:t,duration:n,velocity:r,transition:i,_toggle:h}){var a;const[c="reveal",d="top"]=((a=t[0])==null?void 0:a.split("-"))||[],l=[["left","right"],["top","bottom"]],T=l[s.includes(l[0],d)?0:1],E=T[1]===d,$=["width","height"][l.indexOf(T)],p=`margin-${T[0]}`,v=`margin-${d}`;let m=s.dimensions(o)[$];const j=s.Transition.inProgress(o);await s.Transition.cancel(o),e&&h(o,!0);const H=Object.fromEntries(["padding","border","width","height","minWidth","minHeight","overflowY","overflowX",p,v].map(O=>[O,o.style[O]])),w=s.dimensions(o),P=s.toFloat(s.css(o,p)),x=s.toFloat(s.css(o,v)),f=w[$]+x;!j&&!e&&(m+=x);const[b]=s.wrapInner(o,"<div>");s.css(b,{boxSizing:"border-box",height:w.height,width:w.width,...s.css(o,["overflow","padding","borderTop","borderRight","borderBottom","borderLeft","borderImage",v])}),s.css(o,{padding:0,border:0,minWidth:0,minHeight:0,[v]:0,width:w.width,height:w.height,overflow:"hidden",[$]:m});const C=m/f;n=(r*f+n)*(e?1-C:C);const A={[$]:e?f:0};E&&(s.css(o,p,f-m+P),A[p]=e?P:f+P),!E^c==="reveal"&&(s.css(b,p,-f+m),s.Transition.start(b,{[p]:e?0:-f},n,i));try{await s.Transition.start(o,A,n,i)}finally{s.css(o,H),s.unwrap(b.firstChild),e||h(o,!1)}}function D(o,e,t){s.Animation.cancel(o);const{animation:n,duration:r,_toggle:i}=t;return e?(i(o,!0),s.Animation.in(o,n[0],r,t.origin)):s.Animation.out(o,n[1]||n[0],r,t.origin).then(()=>i(o,!1))}var L={props:{pos:String,offset:null,flip:Boolean,shift:Boolean,inset:Boolean},data:{pos:`bottom-${s.isRtl?"right":"left"}`,offset:!1,flip:!0,shift:!0,inset:!1},connected(){this.pos=this.$props.pos.split("-").concat("center").slice(0,2),[this.dir,this.align]=this.pos,this.axis=s.includes(["top","bottom"],this.dir)?"y":"x"},methods:{positionAt(o,e,t){let n=[this.getPositionOffset(o),this.getShiftOffset(o)];const r=[this.flip&&"flip",this.shift&&"shift"],i={element:[this.inset?this.dir:s.flipPosition(this.dir),this.align],target:[this.dir,this.align]};if(this.axis==="y"){for(const l in i)i[l].reverse();n.reverse(),r.reverse()}const[h]=s.scrollParents(o),{scrollTop:a,scrollLeft:c}=h,d=s.dimensions(o);s.css(o,{top:-d.height,left:-d.width}),s.positionAt(o,e,{attach:i,offset:n,boundary:t,placement:r,viewportOffset:this.getViewportOffset(o)}),h.scrollTop=a,h.scrollLeft=c},getPositionOffset(o){return s.toPx(this.offset===!1?s.css(o,"--uk-position-offset"):this.offset,this.axis==="x"?"width":"height",o)*(s.includes(["left","top"],this.dir)?-1:1)*(this.inset?-1:1)},getShiftOffset(o){return this.align==="center"?0:s.toPx(s.css(o,"--uk-position-shift-offset"),this.axis==="y"?"width":"height",o)*(s.includes(["left","top"],this.align)?1:-1)},getViewportOffset(o){return s.toPx(s.css(o,"--uk-position-viewport-offset"))}}};function y(o,e=o.$el,t=""){if(e.id)return e.id;let n=`${o.$options.id}-${o._uid}${t}`;return s.$(`#${n}`)&&(n=y(o,e,`${t}-2`)),n}const N={TAB:9,ESC:27,SPACE:32,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40};var u={mixins:[g,S,L],args:"title",props:{delay:Number,title:String},data:{pos:"top",title:"",delay:0,animation:["uk-animation-scale-up"],duration:100,cls:"uk-active"},beforeConnect(){this.id=y(this),this._hasTitle=s.hasAttr(this.$el,"title"),s.attr(this.$el,{title:"","aria-describedby":this.id}),_(this.$el)},disconnected(){this.hide(),s.attr(this.$el,"title")||s.attr(this.$el,"title",this._hasTitle?this.title:null)},methods:{show(){this.isToggled(this.tooltip||null)||!this.title||(clearTimeout(this.showTimer),this.showTimer=setTimeout(this._show,this.delay))},async hide(){s.matches(this.$el,"input:focus")||(clearTimeout(this.showTimer),this.isToggled(this.tooltip||null)&&(await this.toggleElement(this.tooltip,!1,!1),s.remove(this.tooltip),this.tooltip=null))},_show(){this.tooltip=s.append(this.container,`<div id="${this.id}" class="uk-${this.$options.name}" role="tooltip"> <div class="uk-${this.$options.name}-inner">${this.title}</div> </div>`),s.on(this.tooltip,"toggled",(o,e)=>{if(!e)return;const t=()=>this.positionAt(this.tooltip,this.$el);t();const[n,r]=F(this.tooltip,this.$el,this.pos);this.origin=this.axis==="y"?`${s.flipPosition(n)}-${r}`:`${r}-${s.flipPosition(n)}`;const i=[s.once(document,`keydown ${s.pointerDown}`,this.hide,!1,h=>h.type===s.pointerDown&&!s.within(h.target,this.$el)||h.type==="keydown"&&h.keyCode===N.ESC),s.on([document,...s.overflowParents(this.$el)],"scroll",t,{passive:!0})];s.once(this.tooltip,"hide",()=>i.forEach(h=>h()),{self:!0})}),this.toggleElement(this.tooltip,!0)}},events:{focus:"show",blur:"hide",[`${s.pointerEnter} ${s.pointerLeave}`](o){s.isTouch(o)||this[o.type===s.pointerEnter?"show":"hide"]()},[s.pointerDown](o){s.isTouch(o)&&this.show()}}};function _(o){s.isFocusable(o)||s.attr(o,"tabindex","0")}function F(o,e,[t,n]){const r=s.offset(o),i=s.offset(e),h=[["left","right"],["top","bottom"]];for(const c of h){if(r[c[0]]>=i[c[1]]){t=c[1];break}if(r[c[1]]<=i[c[0]]){t=c[0];break}}const a=s.includes(h[0],t)?h[1]:h[0];return r[a[0]]===i[a[0]]?n=a[0]:r[a[1]]===i[a[1]]?n=a[1]:n="center",[t,n]}return typeof window<"u"&&window.UIkit&&window.UIkit.component("tooltip",u),u});
